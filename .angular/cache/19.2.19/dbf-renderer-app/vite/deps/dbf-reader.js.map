{
  "version": 3,
  "sources": ["../../../../../../node_modules/dbf-reader/models/dbf-file.js", "../../../../../../node_modules/dbf-reader/dbf-reader.js", "../../../../../../node_modules/dbf-reader/dbf.js"],
  "sourcesContent": ["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass DataTable {\n  constructor() {\n    this.columns = new Array();\n    this.rows = new Array();\n  }\n}\nexports.DataTable = DataTable;\nclass Column {}\nexports.Column = Column;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst dbf_file_1 = require(\"./models/dbf-file\");\nclass DbfReader {\n  static readFieldsInfo(dbaseFile) {\n    try {\n      let byteRead;\n      let fields = new Array();\n      let i = 0;\n      do {\n        byteRead = DbfReader.fileHeaderSize + i * DbfReader.fieldDescriptorSize + 1;\n        let fieldNameLength = 0;\n        while (Buffer.from(dbaseFile.subarray(byteRead + fieldNameLength, byteRead + fieldNameLength + 1)).toString(\"utf8\") != \"\\u0000\" && fieldNameLength < 11) {\n          fieldNameLength += 1;\n        }\n        let fieldName = Buffer.from(dbaseFile.subarray(byteRead, byteRead + fieldNameLength)).toString(\"utf8\");\n        byteRead = byteRead + 11;\n        let fieldType = Buffer.from(dbaseFile.subarray(byteRead, byteRead + 1)).toString(\"utf8\");\n        byteRead = byteRead + 1;\n        byteRead = byteRead + 4; //reserved\n        let fieldLength = dbaseFile.readIntLE(byteRead, 1);\n        byteRead = byteRead + 1;\n        let decimalCount = dbaseFile.readIntLE(byteRead, 1);\n        byteRead = byteRead + 1;\n        fields.push(new DbfReader.FieldDescriptor(fieldName, fieldType, fieldLength, decimalCount));\n        byteRead = byteRead + 14; // Not required to read\n        i += 1;\n      } while (Buffer.from(dbaseFile.subarray(byteRead, byteRead + 1)).toString(\"utf8\") != \"\\r\");\n      return fields;\n    } catch (error) {\n      throw error;\n    }\n  }\n  static getDateValue(value) {\n    try {\n      if (value.length == 8) {\n        let year = value.substr(0, 4);\n        let month = value.substr(4, 2);\n        let date = value.substr(6, 2);\n        return new Date(+year, +month, +date);\n      }\n    } catch (error) {\n      console.log(error);\n    }\n    return null;\n  }\n  static getFieldValue(valueBuffer, type, decimalCount, fieldlength) {\n    let value = valueBuffer.toString('utf8').trim();\n    let byteRead = 0;\n    let valueLength = 0;\n    try {\n      switch (type.trim().toLowerCase()) {\n        case \"q\":\n          value = value;\n          break;\n        case \"v\":\n          while (Buffer.from(valueBuffer.subarray(byteRead + valueLength, byteRead + valueLength + 1)).toString(\"utf8\") != \"\\u0000\" && valueLength < fieldlength) {\n            valueLength += 1;\n          }\n          value = Buffer.from(valueBuffer.subarray(byteRead, byteRead + valueLength)).toString(\"utf8\").trim();\n          break;\n        case \"c\":\n          value = value;\n          break;\n        case \"d\":\n          value = DbfReader.getDateValue(value);\n          break;\n        case \"f\":\n        case \"n\":\n          value = +value;\n          break;\n        case \"l\":\n          if (value.toLowerCase() == \"y\" || value.toLowerCase() == \"t\") {\n            value = true;\n          } else {\n            value = false;\n          }\n          break;\n        case \"g\":\n        case \"i\":\n          value = valueBuffer.readIntLE(0, valueBuffer.byteLength);\n          break;\n        case \"y\":\n          let currency = valueBuffer.readIntLE(0, valueBuffer.byteLength).toString();\n          currency = currency.substr(0, currency.length - decimalCount) + \".\" + currency.substr(currency.length - decimalCount, currency.length - 4);\n          value = +currency;\n          break;\n        case \"b\":\n          value = valueBuffer.readDoubleLE(0);\n          break;\n        case \"t\":\n          let dateWord = valueBuffer.readInt32LE(0);\n          let duration = valueBuffer.readInt32LE(4);\n          let seconds = Math.floor(duration / 1000 % 60);\n          let minutes = Math.floor(duration / (1000 * 60) % 60);\n          let hours = Math.floor(duration / (1000 * 60 * 60) % 24);\n          let date = DbfReader.julianIntToDate(dateWord);\n          value = new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours, minutes, seconds);\n      }\n    } catch (error) {\n      console.log(error);\n    }\n    return value;\n  }\n  static julianIntToDate(jd) {\n    var year, month, day, l, n, i, j, k;\n    l = jd + 68569;\n    n = Math.floor(Math.floor(4 * l) / 146097);\n    l = l - Math.floor((146097 * n + 3) / 4);\n    i = Math.floor(4000 * (l + 1) / 1461001);\n    l = l - Math.floor(1461 * i / 4) + 31;\n    j = Math.floor(80 * l / 2447);\n    k = l - Math.floor(2447 * j / 80);\n    l = Math.floor(j / 11);\n    j = j + 2 - 12 * l;\n    i = 100 * (n - 49) + i + l;\n    year = i;\n    month = j;\n    day = k;\n    let date = new Date(year, month, day);\n    date.setMonth(date.getMonth() - 1);\n    return date;\n  }\n  static getTypeName(type) {\n    let typeName = \"string\";\n    try {\n      switch (type.trim().toLowerCase()) {\n        case \"v\":\n        case \"c\":\n          typeName = \"string\";\n          break;\n        case \"d\":\n          typeName = \"date\";\n          break;\n        case \"y\":\n        case \"i\":\n        case \"g\":\n        case \"b\":\n        case \"f\":\n        case \"n\":\n          typeName = \"numeric\";\n          break;\n        case \"l\":\n          typeName = \"boolean\";\n          break;\n        case \"t\":\n          typeName = \"datetime\";\n          break;\n        // case \"q\": typeName = \"binary\";\n        //     break;\n        default:\n          typeName = \"notsupported\";\n      }\n    } catch (error) {\n      console.log(error);\n    }\n    return typeName;\n  }\n  /**\r\n   * read Dbase DB File\r\n   */\n  static read(dbaseFile) {\n    let dt = new dbf_file_1.DataTable();\n    try {\n      let byteRead = 0;\n      // let dbfFileType: string = Buffer.from(dbaseFile.buffer, byteRead, 1).toString('hex');\n      byteRead = byteRead + 1;\n      // let year: string = Buffer.from(dbaseFile.buffer, byteRead, 1).toString('ascii');\n      byteRead = byteRead + 1;\n      // let month: string = Buffer.from(dbaseFile.buffer, byteRead, 1).toString('ascii');\n      byteRead = byteRead + 1;\n      // let day: string = Buffer.from(dbaseFile.buffer, byteRead, 1).toString('ascii');\n      byteRead = byteRead + 1;\n      // let lastUpdDate: string = year + month + day;\n      let recordCount = dbaseFile.readInt32LE(byteRead);\n      byteRead = byteRead + 4;\n      let recordDataStartOffset = dbaseFile.readInt16LE(byteRead);\n      byteRead = byteRead + 8;\n      // let recordSize: number = dbaseFile.readInt16LE(byteRead);\n      byteRead = byteRead + 8;\n      let fields = DbfReader.readFieldsInfo(dbaseFile);\n      byteRead = recordDataStartOffset + 1;\n      fields.forEach(f => {\n        let dataColumn = new dbf_file_1.Column();\n        dataColumn.name = f.fieldName;\n        dataColumn.type = DbfReader.getTypeName(f.fieldType);\n        if (dataColumn.type != \"notsupported\") {\n          dt.columns.push(dataColumn);\n        }\n      });\n      byteRead = recordDataStartOffset;\n      for (var i = 0; i < recordCount; i++) {\n        let row = {};\n        if (Buffer.from(dbaseFile.subarray(byteRead, byteRead + 1)).toString('utf8') == \" \") {\n          byteRead = byteRead + 1;\n          fields.forEach(col => {\n            let type = DbfReader.getTypeName(col.fieldType);\n            if (col.fieldLength < 0) {\n              col.fieldLength = 256 + col.fieldLength;\n            }\n            if (col.fieldLength > 0) {\n              let value = DbfReader.getFieldValue(Buffer.from(dbaseFile.subarray(byteRead, byteRead + col.fieldLength)), col.fieldType, col.fieldDecimalCount, col.fieldLength);\n              if (type != \"notsupported\") {\n                row[col.fieldName] = value;\n              }\n              byteRead = byteRead + col.fieldLength;\n            } else {\n              throw new SyntaxError(\"Unsupported Dbase (.dbf) file\");\n            }\n          });\n          dt.rows.push(row);\n        } else {\n          byteRead = byteRead + 1;\n          fields.forEach(col => {\n            byteRead = byteRead + col.fieldLength;\n          });\n        }\n      }\n      return dt;\n    } catch (error) {\n      throw error;\n    }\n  }\n}\nDbfReader.fileHeaderSize = 31;\nDbfReader.fieldDescriptorSize = 32;\nDbfReader.FieldDescriptor = class {\n  constructor(fieldName, fieldType, fieldLength, fieldDecimalCount) {\n    this.fieldName = fieldName;\n    this.fieldType = fieldType;\n    this.fieldLength = fieldLength;\n    this.fieldDecimalCount = fieldDecimalCount;\n  }\n};\nexports.DbfReader = DbfReader;", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst dbf_reader_1 = require(\"./dbf-reader\");\nclass Dbf extends dbf_reader_1.DbfReader {\n  /**\r\n   * @Method: Read DBase DB (.dbf file)\r\n   * @Param {Buffer}\r\n   * @Return {DataTable}\r\n   */\n  static read(dbaseFile) {\n    try {\n      if (!dbaseFile || dbaseFile.byteLength == 0) {\n        throw new SyntaxError(\"Dbase DB File can't be null or empty.\");\n      } else {\n        return dbf_reader_1.DbfReader.read(dbaseFile);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n}\nexports.Dbf = Dbf;"],
  "mappings": "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",
  "names": []
}
